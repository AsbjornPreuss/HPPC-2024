\documentclass{article}
\usepackage[sorting=none]{biblatex}
\usepackage{color}
\usepackage{placeins}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{subcaption}
\usepackage{cleveref}
\usepackage{array}
\usepackage{geometry}[margins=1in]
\setlength{\parskip}{4pt plus 2pt}
\setlength{\parindent}{0pt}
%\pagecolor[rgb]{0,0,0} %black
%\color[rgb]{1,1,1} %grey
\lstset{language=C++,
keywordstyle=\color{blue},
stringstyle=\color{red},
commentstyle=\color{green},
morecomment=[l][\color{magenta}]{\#},
breaklines=true,
breakatwhitespace=true,
numbers=left
}
\title{3-Dimensional Heisenberg Model}
\author{Asbj√∏rn Bonefeld Preuss,\\ Daniel Lomholt Christensen,\\ Elie Cueto \\ Frederik Aaboe Andersen \\ Emilie Berg \\ Nete Wenyu Orland Lyndrup}
\date{March 2024}

\renewcommand{\thesection}{Task \#\arabic{section}}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}
\begin{document}
\maketitle

\section{Introduction}
This project seeks to implement the three dimensional Heisenberg model, into C++, and attempt to optimize the implementation, to allow simulations of larger systems, faster.

The project therefore starts with an Introduction to the Heiseberg model, followed by an overview of a sequential implementation, and then the different parallelizations that will be used to optimize the sequential implementation. Finally, a chapter showing the weak and strong scaling of the different versions, as well as profiling of the versions is presented.

\subsection{The Heisenberg Model}
The goal of the Heisenberg model is to predict the behaviour of condensed matter systems.
The Heisenberg model assumes a N$\times$N$\times$N cube, occuppied by N$\times$N$\times$N spins. These spins are vectors that can point in any direction, in 3-d space. Each of these spins are generated with a random spin vector initially. 

Then the Metropolis-Hastings Monte Carlo algorithm is used. This algorithm selects a random site, and flips it in a new, random direction. If the flip minimizes the energy of the system, it is accepted. If not, a flip propability is calculated. This propability is $P=\exp\left(-\frac{\Delta E}{k_bT}\right)$. %TODO: Citation on the propability
A random number is then generated. If the random number is smaller than the propability, the flip is accepted. Otherwise the flip is rejected, and the system remains the same.

The energy of this system is calculated by the Hamiltonian\cite{Heisenberg},
\begin{equation}
    H = - \frac{J}{2}\sum_{n, \lambda}\mathbf{S_n}\cdot\mathbf{S_{n + \lambda}}.
    \label{Hamiltonian}
\end{equation}
At each flip, the energy of the old spin, and new spin must be calculated according to \ref{Hamiltonian}. 

\section{Sequential implementation}
The initial implementation first creates a class \verb|spin_system|, most importantly containing a vector of vectors of positions, and a vector of vectors of spins, that are both initially empty. Two generator functions are then called, that create the positions of the spins, and the spin vectors. After this, another generator finds each spins' neigbours in all directions.

Then the simulation begins. A random site is chosen (seeded by which number of iteration it is), and the energy of the current system, as well as the old spin state is recorded. 

The new spin direction is calculated, as well as put directly into the system of spins, and its energy is found. The two energies are compared, and if the new energy is higher, the probability of acceptance is calculated. A random number (seeded by twice the iteration it is) is found. If the probability is smaller than the random number, the change is not accepted, and the old state of the spin is restored.

This is done flip times, as requested in the command line.

\section{Parallelizations}

\section{Scaling}

\printbibliography

\end{document}