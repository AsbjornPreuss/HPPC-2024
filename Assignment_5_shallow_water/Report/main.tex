\documentclass{article}
\usepackage{color}
\usepackage{placeins}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{subcaption}
\usepackage{cleveref}
\usepackage{geometry}[margins=1in]
\setlength{\parskip}{4pt plus 2pt}
\setlength{\parindent}{0pt}
%\pagecolor[rgb]{0,0,0} %black
%\color[rgb]{1,1,1} %grey
\lstset{language=C++,
keywordstyle=\color{blue},
stringstyle=\color{red},
commentstyle=\color{green},
morecomment=[l][\color{magenta}]{\#},
breaklines=true,
breakatwhitespace=true,
numbers=left
}
\title{Assignment \#4}
\author{Asbj√∏rn Bonefeld Preuss,\\ Daniel Lomholt Christensen,\\ Elie Cueto}
\date{March 2024}

\renewcommand{\thesection}{Task \#\arabic{section}}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}
\begin{document}
\maketitle
\section{OpenACC parallelise the program}
The initial bottlenecks of the program without OpenACC was analysed using gprof. The result can be seen on figure \ref{fig:profiling:seq}. The profiling showed that efforts at parallelising the program should be focused around the integration function.
\begin{figure}[H]
    \includegraphics[width=0.7\textwidth]{./figures/sequential_profile.png}
    \centering
    \caption{Profiling of the sequential code, run with gprof and generated with gprof2dot.}
    \label{fig:profiling:seq}
\end{figure}
We initially had some loops running in parallel on the gpu. 
We did this by initialising an accelerated region around the for loop of the simulation (line 155-164).
We here define which data is copied in, and must be copied out as well. In this function, the calculated version of water_world.e is pushed to the cpu's version of water_history.

On line 158 the integration function is called. In the integration function, the exchange horizontal and vertical ghost lines functions were quickly paralellised with acc parallel loop gang directives.

Next up, the integration function has two nested for loops, that are parallelized with parallel loop collapse.

With this setup we profiled the GPU accelerated code, and this result can be seen in figure \ref{fig:profiling:firstattempt}.
\begin{figure}[H]
    \includegraphics[width=0.7\textwidth]{./figures/sequential_profile.png}
    \centering
    \caption*{Profiling of the first try to parallelise the code. }
\end{figure}


\section{Strong and weak scaling using SLURM}



\FloatBarrier
\section{Source Code}
\label{sec:source}
\lstinputlisting[language=c++]{../Code/sw_parallel.cpp}

\end{document}
